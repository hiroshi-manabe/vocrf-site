<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=utf-8">
<title>test</title>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"></script>
<script type="text/javascript" src="jquery.dump.js"></script>
<style type="text/css">
table {
  width: 960px;
  height: 960px;
  border-collapse: collapse;
  border: 1px solid;>
}
td {
  font-size: 160px;
  width: 320px;
  height: 320px;
  text-align: center;
  border: solid 1px black;
}
.sub_show {
  background-color: #FEF;
  border: solid 1px black;
}
.sub_hide {
  background-color: inherit;
  border: 0;
}
.sub_focus {
  background-color: #CCF;
}
</style>
<script>
var is_touch = ('ontouchstart' in window);
var kCellSize = 320;
var kObliqueRatio = 1;
var kCenterStreakRatio = 1/6;
var kIgnoreZoneRatio = 0.25;
var kTouchZoneRatio = 0.5;
var kLastTrackRatio = 1/6;
var touch_states = {};
var keypad_occupied = { 0 : false, 1 : false };
var kSubKeypadData = [
  ['', 'う', '', 'い', 'あ', 'え', '', 'お', ''],
  ['', 'く', '', 'き', 'か', 'け', '', 'こ', ''],
  ['', 'す', '', 'し', 'さ', 'せ', '', 'そ', ''],
  ['', 'つ', '', 'ち', 'た', 'て', '', 'と', ''],
  ['', 'ぬ', '', 'に', 'な', 'ね', '', 'の', ''],
  ['', 'ふ', '', 'ひ', 'は', 'へ', '', 'ほ', ''],
  ['', 'む', '', 'み', 'ま', 'め', '', 'も', ''],
  ['BS', 'ゆ', 'を', '改', 'や', 'ん', 'わ', 'よ', 'ー'],
  ['', 'る', '？', 'り', 'ら', 'れ', '。', 'ろ', '、']
];

function ToIndex(x, y) {
  if (x < -1 || x > 1 || y < -1 || y > 1) {
    return -1;
  }
  return x + 1 + (y + 1) * 3;
}

function Distance(x, y) {
  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
}

function NormalizePositive(rad) {
  var ret = rad % (Math.PI * 2);
  if (ret < 0) {
    ret += Math.PI * 2;
  }
  return ret;
}

function trace(str) {
  $('#dump_area').text($('#dump_area').text() + ' ' + str);
}

function TouchStart(e) {
  e.preventDefault();
  for (var i = 0; i < 2; ++i) {
    var identifier = 0;
    var keypad_num = -1;
    if (is_touch) {
      if (!(i < event.changedTouches.length)) {
        continue;
      }
      var ok = false;
      for (j = 0; j < 2; ++j) {
        if (!keypad_occupied[j]) {
          keypad_num = j;
          ok = true;
          keypad_occupied[j] = true;
          break;
        }
      }
      if (!ok) {
        return;
      }
      identifier = event.changedTouches[i].identifier;
    } else {
      if (i != 0) {
        continue;
      }
      identifier = 0;
      keypad_num = 0;
    }
    var touch_state = touch_states[identifier] = {};
    touch_state.keypad_state = 'none';
    touch_state.keypad_num = keypad_num;
    var k = touch_state.keypad_num;

    touch_state.touched = true;
    touch_state.start_x = (is_touch ? event.changedTouches[i].pageX : e.pageX);
    touch_state.start_y = (is_touch ? event.changedTouches[i].pageY : e.pageY);
    $('#basic_keypad_' + k).css('top', touch_state.start_y - $('#basic_keypad_' + k).height() / 2)
                           .css('left', touch_state.start_x - $('#basic_keypad_' + k).width() / 2)
                           .show();
    touch_state.cell_sequence = [[0, 0]];
    touch_state.coord_sequence = [[touch_state.start_x, touch_state.start_y]];
    touch_state.cell_base_x = 0;
    touch_state.cell_base_y = 0;
    touch_state.cell_offset_x = 0;
    touch_state.cell_offset_y = 0;
    touch_state.real_cell_x = 0;
    touch_state.real_cell_y = 0;
    touch_state.keypad_state = 'basic';
    touch_state.move_state = 'first';
  }
}

function TouchMove(e) {
  e.preventDefault();
  for (var i = 0; i < 2; ++i) {
    var identifier = 0;
    if (is_touch) {
      if (!(i < event.changedTouches.length)) {
        continue;
      }
      identifier = event.changedTouches[i].identifier;
    } else {
      if (i != 0) {
        continue;
      }
      identifier = 0;
    }
    if (!(identifier in touch_states)) {
      return;
    }
    var touch_state = touch_states[identifier];
    var k = touch_state.keypad_num;

    touch_state.current_x = (is_touch ? event.changedTouches[i].pageX : e.pageX);
    touch_state.current_y = (is_touch ? event.changedTouches[i].pageY : e.pageY);
    var prev_cell = touch_state.cell_sequence[touch_state.cell_sequence.length - 1];
    var found = false;
    var is_inside = false;
    var diff_x = touch_state.current_x - touch_state.start_x;
    var diff_y = touch_state.current_y - touch_state.start_y;
    var distance = Distance(diff_x, diff_y);
    var cell_x = 0;
    var cell_y = 0;

    if (touch_state.move_state == 'first') {
      is_inside = true;
      if (distance < kCellSize / 2) {
        cell_x = 0;
        cell_y = 0;
      } else if (distance > kCellSize * 5 / 2) {
        is_inside = false;
      } else {
        touch_state.rad = Math.atan2(diff_y, diff_x);
        var rad = touch_state.rad;
        var straight_rad = (Math.PI / 2) / (1 + kObliqueRatio) * 1;
        var oblique_rad = (Math.PI / 2) / (1 + kObliqueRatio) * kObliqueRatio;
        rad = NormalizePositive(rad + straight_rad / 2);
        var rad_index = Math.floor(rad / (Math.PI / 2));
        var cell_index = rad_index * 2;
        if (rad - rad_index * (Math.PI / 2) > straight_rad) {
          ++cell_index;
        }
        var coord = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]][cell_index];
        cell_x = coord[0];
        cell_y = coord[1];
        touch_state.first_cell_x = cell_x;
        touch_state.first_cell_y = cell_y;
        touch_state.move_state = 'second';
        found = true;
      }
    } else if (touch_state.move_state == 'second') {
      is_inside = true;
      var moved = false;
      var rad = touch_state.rad;
      var rotated_x = diff_x * Math.cos(rad) + diff_y * Math.sin(rad);
      var rotated_y = -diff_x * Math.sin(rad) + diff_y * Math.cos(rad);
      var deviation = Math.abs(rotated_y);
      if (deviation < kCellSize * kCenterStreakRatio / 2) {
        found = true;
        if (distance < kCellSize / 2) {
          cell_x = 0;
          cell_y = 0;
          moved = true;
        } else if (distance < kCellSize * 3 / 2) {
          cell_x = touch_state.first_cell_x;
          cell_y = touch_state.first_cell_y;
        } else if (distance < kCellSize * 5 / 2) {
          cell_x = touch_state.first_cell_x * 2;
          cell_y = touch_state.first_cell_y * 2;
          moved = true;
        } else {
          is_inside = false;
          found = false;
        }
      } else if (deviation < kCellSize * kIgnoreZoneRatio) {
        found = false;
      } else if (deviation < kCellSize * kTouchZoneRatio) {
        var j;
        for (j = touch_state.coord_sequence.length - 1; j >= 0; --j) {
          if (Distance(touch_state.current_x - touch_state.coord_sequence[j][0],
                       touch_state.current_y - touch_state.coord_sequence[j][1]) >
             kCellSize * kLastTrackRatio) {
            break;
          }
        }
        var move_x = touch_state.current_x - touch_state.coord_sequence[j][0];
        var move_y = touch_state.current_y - touch_state.coord_sequence[j][1];
        var move_rad = Math.atan2(move_y, move_x);
        var rad_rotated = NormalizePositive(move_rad - rad + Math.PI * 1 / 8);
        var cell_index = Math.floor(rad_rotated / (Math.PI / 4));
        var first_cell_rad = Math.atan2(touch_state.first_cell_y, touch_state.first_cell_x);
        var cell_list;
        if (touch_state.first_cell_x != 0 && touch_state.first_cell_y != 0) {
          first_cell_rad -= Math.PI / 4;
          cell_list = [null, [0, 1], [-1, 1], [-1, 0], null, [0, -1], [1, -1], [1, 0], null];
        } else {
          cell_list = [null, [1, 1], [0, 1], [-1, 1], null, [-1, -1], [0, -1], [1, -1], null];
        }
        if (cell_list) {
          var cell_tmp = cell_list[cell_index];
          if (cell_tmp) {
            cell_x = touch_state.first_cell_x +
                     Math.round(cell_tmp[0] * Math.cos(first_cell_rad) -
                                cell_tmp[1] * Math.sin(first_cell_rad));
            cell_y = touch_state.first_cell_y +
                     Math.round(cell_tmp[0] * Math.sin(first_cell_rad) +
                                cell_tmp[1] * Math.cos(first_cell_rad));
            found = true;
            moved = true;
          }
        }
        if (moved) {
          touch_state.move_state = 'third';
          touch_state.second_x = touch_state.current_x;
          touch_state.second_y = touch_state.current_y;
        }
      } else {
        is_inside = false;
      }
      if (!is_inside) {
        touch_state.move_state = 'free';
      }
    } else if (touch_state.move_state == 'third') {
      if (Distance(touch_state.current_x - touch_state.second_x,
                   touch_state.current_y - touch_state.second_y) < kCellSize) {
        is_inside = true;
      } else {
        touch_state.move_state = 'free';
      }
    }

    touch_state.coord_sequence.push([touch_state.current_x, touch_state.current_y]);

    var real_cell_x;
    var real_cell_y;
    var real_cell_found = false;
    for (var x = -2; x <= 2; ++x) {
      for (var y = -2; y <= 2; ++y) {
        if (Distance(diff_x - x * kCellSize, diff_y - y * kCellSize) < kCellSize / 2) {
          real_cell_x = x;
          real_cell_y = y;
          real_cell_found = true;
          break;
        }
      }
      if (real_cell_found) {
        break;
      }
    }

    if (!is_inside && !(touch_state.real_cell_x == real_cell_x &&
                    touch_state.real_cell_y == real_cell_y)) {
      found = true;
      cell_x = real_cell_x;
      cell_y = real_cell_y;
    }

    touch_state.real_cell_x = real_cell_x;
    touch_state.real_cell_y = real_cell_y;
    
    if (!found) {
      return;
    }

    touch_state.cell_sequence.push([cell_x, cell_y]);
    touch_state.cell_offset_x = cell_x - touch_state.cell_base_x;
    touch_state.cell_offset_y = cell_y - touch_state.cell_base_y;
    var index = ToIndex(touch_state.cell_offset_x, touch_state.cell_offset_y);

    if (touch_state.keypad_state == 'sub') {
      var base_index = ToIndex(touch_state.cell_base_x, touch_state.cell_base_y);
      $('.sub_key_' + k).removeClass('sub_focus');
      if (index >= 0 && index < 9 && kSubKeypadData[base_index][index] != '') {
        $('#sub_' + k + '_' + index).addClass('sub_focus');
        return;
      }
    }

    index = ToIndex(cell_x, cell_y);
    if ((touch_state.keypad_state == 'sub' && index >=0 && index < 9) ||
        (touch_state.keypad_state == 'basic' && index >= 0 && index < 9 && index != 4)) {
      touch_state.cell_base_x = cell_x;
      touch_state.cell_base_y = cell_y;
      touch_state.cell_offset_x = 0;
      touch_state.cell_offset_y = 0;
    
      for (var j = 0; j < 9; ++j) {
        if (kSubKeypadData[index][j] == '') {
          $('#sub_' + k + '_' + j).addClass('sub_hide').removeClass('sub_show').text('');
        } else {
          $('#sub_' + k + '_' + j).addClass('sub_show').removeClass('sub_hide')
                                  .text(kSubKeypadData[index][j]);
        }
      }
      $('#sub_keypad_' + k).css('top', touch_state.start_y - $('#sub_keypad_' + k).height() / 2 +
                                cell_y * kCellSize)
                           .css('left', touch_state.start_x - $('#sub_keypad_' + k).width() / 2 +
                                cell_x * kCellSize)
                           .show();
      touch_state.keypad_state = 'sub';
      $('.sub_key_' + k).removeClass('sub_focus');
      $('#sub_' + k + '_' + ToIndex(0, 0)).addClass('sub_focus');
    }
  }
}

function TouchEnd(e) {
  e.preventDefault();
  for (var i = 0; i < 2; ++i) {
    var identifier = 0;
    if (is_touch) {
      if (!(i < event.changedTouches.length)) {
        continue;
      }
      identifier = event.changedTouches[i].identifier;
    } else {
      if (i != 0) {
        continue;
      }
      identifier = 0;
    }
    var touch_state = touch_states[identifier];
    var k = touch_state.keypad_num;

    if (touch_state.keypad_state == 'sub') {
      var base_index = ToIndex(touch_state.cell_base_x, touch_state.cell_base_y);
      var index = ToIndex(touch_state.cell_offset_x, touch_state.cell_offset_y);
      if (index >= 0 && index < 9) {
        var text = kSubKeypadData[base_index][index];
        if (text != '') {
          cur_text = $('#state_area').html();
          if (text == 'BS') {
            cur_text = cur_text.replace(/(<br>|.)$/, '');
          } else {
            if (text == '改') {
              text = '<br>';
            }
            cur_text += text;
          }
          $('#state_area').html(cur_text);
        }
      }
    }
    touch_state.keypad_state = 'none';
    $('.sub_key_' + k).removeClass('sub_focus');
    $('#sub_keypad_' + k).hide();
    $('#basic_keypad_' + k).hide();
    delete touch_states[identifier];
    delete touch_state;
    keypad_occupied[k] = false;
  }
}

$(document).ready(function(){
$(document.body).bind({
  'touchstart mousedown': TouchStart,
  'touchmove mousemove': TouchMove,
  'touchend mouseup': TouchEnd
});
});

</script>
</head>
<body>
<span id='state_area' style='font-size: 50px;'></span>
<div id='dump_area'></div>
<div id='keypad_area'>
<table id='basic_keypad_0' style='display: none; position: absolute;'>
<tr>
<td>あ</td>
<td>か</td>
<td>さ</td>
</tr>
<tr>
<td>た</td>
<td>な</td>
<td>は</td>
</tr>
<tr>
<td>ま</td>
<td>や</td>
<td>ら</td>
</tr>
</table>
<table id='basic_keypad_1' style='display: none; position: absolute;'>
<tr>
<td>あ</td>
<td>か</td>
<td>さ</td>
</tr>
<tr>
<td>た</td>
<td>な</td>
<td>は</td>
</tr>
<tr>
<td>ま</td>
<td>や</td>
<td>ら</td>
</tr>
</table>
<table id='sub_keypad_0' style='display: none; border: none; position: absolute;'>
<tr>
<td id='sub_0_0' class='sub_key_0'></td>
<td id='sub_0_1' class='sub_key_0'></td>
<td id='sub_0_2' class='sub_key_0'></td>
</tr>
<tr>
<td id='sub_0_3' class='sub_key_0'></td>
<td id='sub_0_4' class='sub_key_0'></td>
<td id='sub_0_5' class='sub_key_0'></td>
</tr>
<tr>
<td id='sub_0_6' class='sub_key_0'></td>
<td id='sub_0_7' class='sub_key_0'></td>
<td id='sub_0_8' class='sub_key_0'></td>
</tr>
</table>
<table id='sub_keypad_1' style='display: none; border: none; position: absolute;'>
<tr>
<td id='sub_1_0' class='sub_key_1'></td>
<td id='sub_1_1' class='sub_key_1'></td>
<td id='sub_1_2' class='sub_key_1'></td>
</tr>
<tr>
<td id='sub_1_3' class='sub_key_1'></td>
<td id='sub_1_4' class='sub_key_1'></td>
<td id='sub_1_5' class='sub_key_1'></td>
</tr>
<tr>
<td id='sub_1_6' class='sub_key_1'></td>
<td id='sub_1_7' class='sub_key_1'></td>
<td id='sub_1_8' class='sub_key_1'></td>
</tr>
</table>
</div>
</body>
</html>
